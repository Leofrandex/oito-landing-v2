<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Threads 3840x2160 Exact Port</title>
    <style>
        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            min-height: 100%;
            background: #222;
            /* Dark background to preview transparency better */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            font-family: sans-serif;
            overflow-y: auto;
        }

        #container {
            width: 3840px;
            height: 2160px;
            background: rgba(0, 67, 70, 0.5);
            /* Optional: semi-transparent teal just for preview */
            position: relative;
            margin: 20px;
            box-shadow: 0 0 40px rgba(0, 0, 0, 0.5);
            /* Checkerboard to see transparency */
            background-image:
                linear-gradient(45deg, #333 25%, transparent 25%),
                linear-gradient(-45deg, #333 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #333 75%),
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
            border: 1px solid #444;
        }

        canvas {
            display: block;
            width: 100% !important;
            height: 100% !important;
        }

        #downloadBtn {
            position: fixed;
            bottom: 20px;
            right: 20px;
            padding: 15px 30px;
            background: #09bc8a;
            color: #004346;
            border: none;
            border-radius: 8px;
            font-weight: bold;
            cursor: pointer;
            z-index: 1000;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.3);
        }

        .desc {
            position: fixed;
            top: 20px;
            left: 20px;
            background: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="desc">
        <strong>Exact Threads Port (3840x2160)</strong><br>
        Ported directly from <code>Threads.tsx</code>.<br>
        Background: Transparent.<br>
        Format: 3840px x 2160px.
    </div>
    <div id="container"></div>
    <button id="downloadBtn">Download 3840x2160 Transparent PNG</button>

    <script type="module">
        import { Renderer, Program, Mesh, Triangle, Color, Vec2 } from 'https://cdn.skypack.dev/ogl';

        // EXACT SHADER FROM Threads.tsx
        const vertexShader = `
            attribute vec2 position;
            attribute vec2 uv;
            varying vec2 vUv;
            void main() {
                vUv = uv;
                gl_Position = vec4(position, 0.0, 1.0);
            }
        `;

        const fragmentShader = `
            precision highp float;

            uniform float iTime;
            uniform vec3 iResolution;
            uniform vec3 uColor;
            uniform float uAmplitude;
            uniform float uDistance;
            uniform vec2 uMouse;

            #define PI 3.1415926538

            const int u_line_count = 40;
            const float u_line_width = 7.0;
            const float u_line_blur = 10.0;

            float Perlin2D(vec2 P) {
                vec2 Pi = floor(P);
                vec4 Pf_Pfmin1 = P.xyxy - vec4(Pi, Pi + 1.0);
                vec4 Pt = vec4(Pi.xy, Pi.xy + 1.0);
                Pt = Pt - floor(Pt * (1.0 / 71.0)) * 71.0;
                Pt += vec2(26.0, 161.0).xyxy;
                Pt *= Pt;
                Pt = Pt.xzxz * Pt.yyww;
                vec4 hash_x = fract(Pt * (1.0 / 951.135664));
                vec4 hash_y = fract(Pt * (1.0 / 642.949883));
                vec4 grad_x = hash_x - 0.49999;
                vec4 grad_y = hash_y - 0.49999;
                vec4 grad_results = inversesqrt(grad_x * grad_x + grad_y * grad_y)
                    * (grad_x * Pf_Pfmin1.xzxz + grad_y * Pf_Pfmin1.yyww);
                grad_results *= 1.4142135623730950;
                vec2 blend = Pf_Pfmin1.xy * Pf_Pfmin1.xy * Pf_Pfmin1.xy
                           * (Pf_Pfmin1.xy * (Pf_Pfmin1.xy * 6.0 - 15.0) + 10.0);
                vec4 blend2 = vec4(blend, vec2(1.0 - blend));
                return dot(grad_results, blend2.zxzx * blend2.wwyy);
            }

            float pixel(float count, vec2 resolution) {
                return (1.0 / max(resolution.x, resolution.y)) * count;
            }

            float lineFn(vec2 st, float width, float perc, float offset, vec2 mouse, float time, float amplitude, float distance) {
                float split_offset = (perc * 0.4);
                float split_point = 0.1 + split_offset;

                float amplitude_normal = smoothstep(split_point, 0.7, st.x);
                float amplitude_strength = 0.5;
                float finalAmplitude = amplitude_normal * amplitude_strength
                                       * amplitude * (1.0 + (mouse.y - 0.5) * 0.2);

                float time_scaled = time / 10.0 + (mouse.x - 0.5) * 1.0;
                float blur = smoothstep(split_point, split_point + 0.05, st.x) * perc;

                float xnoise = mix(
                    Perlin2D(vec2(time_scaled, st.x + perc) * 2.5),
                    Perlin2D(vec2(time_scaled, st.x + time_scaled) * 3.5) / 1.5,
                    st.x * 0.3
                );

                float y = 0.5 + (perc - 0.5) * distance + xnoise / 2.0 * finalAmplitude;

                float line_start = smoothstep(
                    y + (width / 2.0) + (u_line_blur * pixel(1.0, iResolution.xy) * blur),
                    y,
                    st.y
                );

                float line_end = smoothstep(
                    y,
                    y - (width / 2.0) - (u_line_blur * pixel(1.0, iResolution.xy) * blur),
                    st.y
                );

                return clamp(
                    (line_start - line_end) * (1.0 - smoothstep(0.0, 1.0, pow(perc, 0.3))),
                    0.0,
                    1.0
                );
            }

            void main() {
                // gl_FragCoord is in screen space [0, resolution]
                vec2 uv = gl_FragCoord.xy / iResolution.xy;

                float line_strength = 1.0;
                for (int i = 0; i < u_line_count; i++) {
                    float p = float(i) / float(u_line_count);
                    line_strength *= (1.0 - lineFn(
                        uv,
                        u_line_width * pixel(1.0, iResolution.xy) * (1.0 - p),
                        p,
                        (PI * 1.0) * p,
                        uMouse,
                        iTime,
                        uAmplitude,
                        uDistance
                    ));
                }

                float colorVal = 1.0 - line_strength;
                // Output color with alpha for transparency
                gl_FragColor = vec4(uColor, colorVal);
            }
        `;

        const container = document.getElementById('container');
        const renderer = new Renderer({ alpha: true, preserveDrawingBuffer: true, antialias: true });
        const gl = renderer.gl;
        container.appendChild(gl.canvas);

        const geometry = new Triangle(gl);
        const program = new Program(gl, {
            vertex: vertexShader,
            fragment: fragmentShader,
            uniforms: {
                iTime: { value: 0 },
                iResolution: { value: new Color(gl.canvas.width, gl.canvas.height, gl.canvas.width / gl.canvas.height) },
                uColor: { value: new Color(0.035, 0.737, 0.541) }, // Mint Green: #09bc8a
                uAmplitude: { value: 2.0 }, // Increased for impact on A4
                uDistance: { value: 0.1 }, // Matches Threads.tsx default 0
                uMouse: { value: new Vec2(0.5, 0.5) }
            }
        });

        const mesh = new Mesh(gl, { geometry, program });

        function resize() {
            // Exact dimensions: 3840x2160 pixel
            const width = container.clientWidth;
            const height = container.clientHeight;
            renderer.setSize(width, height);
            program.uniforms.iResolution.value.r = width;
            program.uniforms.iResolution.value.g = height;
            program.uniforms.iResolution.value.b = width / height;
        }
        window.addEventListener('resize', resize);
        resize();

        function update(t) {
            program.uniforms.iTime.value = t * 0.001;
            renderer.render({ scene: mesh });
            requestAnimationFrame(update);
        }
        requestAnimationFrame(update);

        document.getElementById('downloadBtn').onclick = () => {
            const link = document.createElement('a');
            link.timestamp = new Date().getTime();
            link.download = `threads_3840x2160_${link.timestamp}.png`;
            link.href = gl.canvas.toDataURL('image/png');
            link.click();
        };
    </script>
</body>

</html>